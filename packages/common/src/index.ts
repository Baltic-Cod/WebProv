export { uniqueId } from './utils';

// All possible relationships types. The values can be used for display purposes.
export const provenanceNodeRelationshipsMap = {
  'used': 'Used',
  'used-for-validation': 'Used for validation',
  'used-for-calibration': 'Used for calibration',
  'derived-from': 'Derived from',
  'generated-by': 'Generated by',
};

export type ProvenanceNodeRelationships = keyof typeof provenanceNodeRelationshipsMap;

export const provenanceNodeRelationships = Object.keys(provenanceNodeRelationshipsMap) as ProvenanceNodeRelationships[];

interface RelationshipConstraints {
  /**
   * The type of relationship.
   */
  relationship: ProvenanceNodeRelationships;

  /**
   * Whether this relationship is a one-to-ony relationship. By default, it is a one-to-many relationship.
   */
  single?: boolean;
}

type RelationshipRules = {
  [A in ProvenanceNodeType]: {
    [B in ProvenanceNodeType]?: Array<ProvenanceNodeRelationships | RelationshipConstraints>
  }
};

export const relationshipRules: RelationshipRules = {
  'ModelBuildingActivity': {
    'WetLabData': [
      'used-for-validation',
      'used-for-calibration',
    ],
    'SimulationData': [
      'used-for-validation',
      'used-for-calibration',
    ],
    'Model': ['used'],
  },
  'Model': {
    'Model': [{
      relationship: 'derived-from',
      single: true,
    }],
    'ModelBuildingActivity': [{
      relationship: 'generated-by',
      single: true,
    }],
  },
  'ModelExplorationActivity': {
    Model: [{
      relationship: 'used',
      single: true,
    }],
  },
  'SimulationData': {
    'ModelBuildingActivity': [{
      relationship: 'generated-by',
      single: true,
    }],
    'ModelExplorationActivity': [{
      relationship: 'generated-by',
      single: true,
    }],
  },
  'WetLabData': {
    // no possible relationships
  },
};

export interface ProvenanceNodeConnection {
  /**
   * The connection ID.
   */
  id: string;

  /**
   * The ID of the target node.
   */
  targetId: string;

  /**
   * The type of relationship.
   */
  type: ProvenanceNodeRelationships;
}

interface BaseNode {
  /**
   * The unique id.
   */
  id: string;

  /**
   * The model id. This information is what links nodes together.
   */
  modelId?: number;

  /**
   * The connections.
   */
  connections?: ProvenanceNodeConnection[];
}

export interface ModelBuildingActivity extends BaseNode {
  /**
   * The node identifier. Very useful since JavaScript doesn't really have classes so we use this attribute
   * to see which type of node we have.
   */
  type: 'ModelBuildingActivity';
}

export interface ModelExplorationActivity extends BaseNode {
  /**
   * The node identifier. Very useful since JavaScript doesn't really have classes so we use this attribute
   * to see which type of node we have.
   */
  type: 'ModelExplorationActivity';
}

export interface ModelInformation {
  /**
   * The unique id. This number corresponds to the model number. Should >= 1.
   */
  id: number;

  /**
   * The signaling pathway information.
   */
  signalingPathway?: string;

  /**
   * The information regarding the source of the model. For example, `Haack et al., PLoS comp. bio. 2015`.
   */
  source?: string;
}

export interface Model extends BaseNode {
  /**
   * The node identifier. Very useful since JavaScript doesn't really have classes so we use this attribute
   * to see which type of node we have.
   */
  type: 'Model';

  /**
   * The version! This should start at 1 and then increment for each version. A model should never depend
   * on a model that has a higher version number (or itself).
   */
  version?: number;
}

export interface WetLabData extends BaseNode {
  /**
   * The node identifier. Very useful since JavaScript doesn't really have classes so we use this attribute
   * to see which type of node we have.
   */
  type: 'WetLabData';

  /**
   * The name of the wet lab experiment.
   */
  name?: string;

  /**
   * Just extra information about the wet lab data. For example, this might contain cell line information.
   */
  information?: Array<[string, string]>;
}

export interface SimulationData extends BaseNode {
  /**
   * The node identifier. Very useful since JavaScript doesn't really have classes so we use this attribute
   * to see which type of node we have.
   */
  type: 'SimulationData';

  /**
   * The name of the simulation.
   */
  name?: string;
}

export type ProvenanceNode = ModelBuildingActivity | ModelExplorationActivity | Model | WetLabData | SimulationData;
export interface ProvenanceNodeLookup {
  'Model': Model;
  'ModelBuildingActivity': ModelBuildingActivity;
  'ModelExplorationActivity': ModelExplorationActivity;
  'WetLabData': WetLabData;
  'SimulationData': SimulationData;
}

export type ProvenanceNodeType = keyof ProvenanceNodeLookup;

type ProvenanceNodeDisplayTestLookup = { [Type in ProvenanceNodeType]: string };

export const provenanceNodeTypeDisplayText: ProvenanceNodeDisplayTestLookup = {
  'Model': 'Model',
  'ModelBuildingActivity': 'Model Building Activity',
  'ModelExplorationActivity': 'Model Exploration Activity',
  'SimulationData': 'Simulation Data',
  'WetLabData': 'Wet Lab Data',
};

export const provenanceNodeTypes = Object.keys(provenanceNodeTypeDisplayText) as ProvenanceNodeType[];
