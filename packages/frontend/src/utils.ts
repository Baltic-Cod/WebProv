import { Watch as W } from 'vue-property-decorator';
import { WatchOptions } from 'vue';
import { ProvenanceNode } from 'specification';
import { NodeRelationship } from './constants';

export const makeLookup = <T extends { id: string }>(array: Iterable<T>) => {
  const lookup: Lookup<T> = {};
  for (const item of array) {
    lookup[item.id] = item;
  }
  return lookup;
};

export interface Lookup<T> { [k: string]: T; }

export function Watch<T>(path: keyof T & string, options?: WatchOptions) {
  return W(path, options);
}


export function getText(n: ProvenanceNode): string {
  switch (n.type) {
    case 'wet-lab data':
      return n.name;
    case 'model-building-activity':
      return 'MBA';
    case 'simulation data':
      return n.name;
    case 'model exploration activity':
      return 'MEA';
    case 'model':
      if (n.version < 1) {
        throw Error(`Bad model version number: ${n.version}. Expected value >= 1`);
      }

      let text = `M${n.modelInformation.modelNumber}`;

      if (n.version === 1) {
        // Do nothing is the version is 1
      } else if (n.version === 2) {
        // Just add an apostrophe if the version is 2
        text += `'`;
      } else {
        // Add an explicit version number if > 2
        text += `v${n.version}`;
      }

      return text + ` (${n.modelInformation.bibInformation})`;
  }
}

export const notNull = <T>(t: T | null): t is T => {
  return t !== null;
};

type Connections = [ProvenanceNode[], NodeRelationship];

export function getConnections(n: ProvenanceNode): Connections[] {
  let setsToConnect: Array<[ProvenanceNode[] | ProvenanceNode | null, NodeRelationship]> = [];
  switch (n.type) {
    case 'wet-lab data':
      break;
    case 'model-building-activity':
      setsToConnect = [
        [n.wetLabsUsedForValidation, 'Used for validation'],
        [n.wetLabsUsedForCalibration, 'Used for calibration'],
        [n.simulationsUsedForValidation, 'Used for validation'],
        [n.simulationsUsedForCalibration, 'Used for calibration'],
        [n.used, 'Used'],
      ];
      break;
    case 'simulation data':
      setsToConnect = [
        [n.wasGeneratedByModelBuildingActivity, 'Was generated by'],
        [n.wasGeneratedByModelExplorationActivity, 'Was generated by'],
      ];
      break;
    case 'model exploration activity':
      setsToConnect = [[n.used, 'Used']];
      break;
    case 'model':
      setsToConnect = [[n.wasGeneratedBy, 'Used'], [n.derivedFrom, 'Derived from']];
  }

  return setsToConnect.map(([nodesToConnect, relationship]) => {
    if (nodesToConnect === null) {
      return null;
    }

    if (!Array.isArray(nodesToConnect)) {
      nodesToConnect = [nodesToConnect];
    }

    return [nodesToConnect, relationship] as Connections;
  }).filter(notNull);
}


export function getInformationFields(node: ProvenanceNode, title: string) {
  const fields: Array<[string, string]> = [['Title', title]];

  switch (node.type) {
    case 'model-building-activity':
      break;
    case 'model exploration activity':
      break;
    case 'model':
      fields.push(['Source', node.modelInformation.bibInformation]);
      fields.push(['Model Number', '' + node.modelInformation.modelNumber]);
      fields.push(['Version', '' + node.version]);
      break;
    case 'wet-lab data':
      const information = node.information ? node.information : {};
      Object.keys(information).forEach((key) => {
        fields.push([key, information[key]]);
      });
      break;
    case 'simulation data':
      break;
  }

  return fields;
}

type Events = keyof WindowEventMap;

type EventListener<K extends Events> = (ev: WindowEventMap[K]) => any;

export const once = <K extends Events>(
  type: K,
  listener: EventListener<K>,
  options?: boolean | AddEventListenerOptions,
) => {
  function callAndRemove(ev: WindowEventMap[K]) {
    listener(ev);
    window.removeEventListener(type, listener);
  }

  window.addEventListener(type, callAndRemove, options);
};

export const addEventListener = <K extends Events>(
  type: K,
  ev: EventListener<K>,
  options?: boolean | AddEventListenerOptions,
) => {
  window.addEventListener(type, ev, options);

  return () => {
    window.removeEventListener(type, ev);
  };
};

type EventListeners = {
  [P in keyof WindowEventMap]?: EventListener<P> | 'remove';
};

export const addEventListeners = (
  events: EventListeners,
  options?: boolean | AddEventListenerOptions,
) => {
  const types = Object.keys(events) as Events[];

  const remove = () => {
    for (const type of types) {
      const ev = events[type];
      if (ev === 'remove') {
        continue;
      }

      window.removeEventListener(type, ev as any);
    }
  };

  for (const type of types) {
    const ev = events[type];
    if (ev === 'remove') {
      events[type] = remove;
    }
    window.addEventListener(type, ev as any, options);
  }


  return remove;
};
